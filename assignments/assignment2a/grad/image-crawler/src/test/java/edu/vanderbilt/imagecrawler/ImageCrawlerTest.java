package edu.vanderbilt.imagecrawler;

import junit.framework.AssertionFailedError;

import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.AbstractMap;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import edu.vanderbilt.crawlers.SequentialLoopsCrawler;
import edu.vanderbilt.crawlers.SequentialStreamsCrawler;
import edu.vanderbilt.crawlers.framework.CrawlerFactory;
import edu.vanderbilt.crawlers.framework.ImageCrawlerBase;
import edu.vanderbilt.filters.Filter;
import edu.vanderbilt.filters.FilterFactory;
import edu.vanderbilt.platform.Device;
import edu.vanderbilt.platform.JavaPlatform;
import edu.vanderbilt.utils.CacheUtils;
import edu.vanderbilt.utils.LocalPageCrawler;
import edu.vanderbilt.utils.Options;
import edu.vanderbilt.utils.WebPageCrawler;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

/**
 * Tests local and remove web crawling.
 */
public class ImageCrawlerTest {
    /**
     * These fields are used to locate the project resources directory.
     */
    private static final String ASSETS_PATH = "app/src/main/assets";
    private static final String RESOURCES_PATH = "image-crawler/src/main/resources";
    private static final String GROUND_TRUTH_DIR_NAME = "ground-truth";

    /**
     * Keep track of the timing results of the ImageCrawler
     * implementation strategies so they can be sorted and displayed
     * when the program is finished.
     */
    private Map<String, List<Long>> mResultsMap =
        new HashMap<>();

    /**
     * Compares the current contents of the download cache directory
     * with the ground-truth directory located in the library resources
     * directory. The ground-truth directory can be regenerated by running
     * the @Test method in the DownloadToResourcesAndAssets test class.
     */
    @Test
    public void testDownloadCacheMatchesGroundTruthFiles() throws Exception {
        // Device protects itself from multiple builds and this
        // method gets around that restriction.
        Device.setPrivateInstanceFieldToNullForUnitTestingOnly();

        // Create a new device along with default options so that we
        // can call CacheUtils.getCacheDir(). This method needs to get
        // the default download directory name from the Options
        // instance that lives in the Device object.
        Device.newBuilder()
            .platform(new JavaPlatform())
            .options(Options.newBuilder()
                     .local(false)
                     .diagnosticsEnabled(true)
                     .build())
            .crawler(new WebPageCrawler())
            .build();

        List<FilterFactory.Type> filterTypes =
                Collections.singletonList(FilterFactory.Type.NULL_FILTER);

        // Create and run the crawler.
        CrawlerFactory.newCrawler(
                CrawlerFactory.Type.SEQUENTIAL_STREAMS,
                filterTypes,
                Device.options().getRootUri()).run();

        File groundTruthDir = new File(getResourcesDir(), GROUND_TRUTH_DIR_NAME);
        File downloadCacheDir = CacheUtils.getCacheDir();

        // Recursively compare the downloadCacheDir directory with
        // groundTruthDir directory.
        recursivelyCompareDirectories(groundTruthDir,
                                      downloadCacheDir);
    }

    /**
     * Recursively compare the contents of the directory of downloaded
     * files with the contents of the "ground truth" directory.
     */
    private void recursivelyCompareDirectories(File expected,
                                               File generated)
        throws IOException {
        // Checks parameters.
        assertTrue("Generated Folder doesn't exist: " + generated,
                   generated.exists());
        assertTrue("Generated is not a folder?!?!: " + generated,
                   generated.isDirectory());

        assertTrue("Expected Folder doesn't exist: " + expected,
                   expected.exists());
        assertTrue("Expected is not a folder?!?!: " + expected,
                   expected.isDirectory());

        Files.walkFileTree(expected.toPath(),
                           new SimpleFileVisitor<Path>() {
                               @Override
                               public FileVisitResult preVisitDirectory(Path dir,
                                                                        BasicFileAttributes attrs)
                                   throws IOException {
                                   FileVisitResult result =
                                       super.preVisitDirectory(dir, attrs);

                                   // Get the relative file name from
                                   // path "expected"
                                   Path relativize =
                                       expected.toPath().relativize(dir);

                                   // Construct the path for the
                                   // counterpart file in "generated"
                                   File otherDir =
                                       generated.toPath().resolve(relativize).toFile();

                                   assertEquals("Folders doesn't contain same file!?!?",
                                                Arrays.toString(dir.toFile().list()),
                                                Arrays.toString(otherDir.list()));
                                   return result;
                               }

                               @Override
                               public FileVisitResult visitFile(Path file,
                                                                BasicFileAttributes attrs)
                                   throws IOException {
                                   FileVisitResult result =
                                       super.visitFile(file, attrs);

                                   // Get the relative file name from
                                   // path "expected".
                                   Path relativize =
                                       expected.toPath().relativize(file);

                                   // Construct the path for the
                                   // counterpart file in "generated".
                                   Path fileInOther =
                                       generated.toPath().resolve(relativize);

                                   byte[] otherBytes = Files.readAllBytes(fileInOther);
                                   byte[] thisBytes = Files.readAllBytes(file);

                                   if (!Arrays.equals(otherBytes, thisBytes))
                                       throw new AssertionFailedError(file + " is not equal to " + fileInOther);

                                   return result;
                               }
                           });
    }

    /**
     * This method is the static main() entry point to run the console
     * version of the ImageCrawler app.
     */
    // @Test
    public void testLocalImageCrawlerNullFilterOnly() {
        System.out.println("Starting testLocalImageCrawler");

        // Device protects itself from multiple builds and this
        // method gets around that restriction.
        Device.setPrivateInstanceFieldToNullForUnitTestingOnly();

        // Create a new device with a local page crawler.
        Device.newBuilder()
            .platform(new JavaPlatform())
            .options(Options.newBuilder()
                     .local(true)
                     .diagnosticsEnabled(true)
                     .build())
            .crawler(new LocalPageCrawler())
            .build();

        // Delete any the filtered images from the previous run.
        CacheUtils.clearCache();

        String rootUri =  Device.options().getRootUri();

        Filter filter = FilterFactory.newFilter(FilterFactory.Type.NULL_FILTER);

        List<Filter> filters = Stream.of(filter).collect(Collectors.toList());

        SequentialStreamsCrawler crawler = new SequentialStreamsCrawler(filters, rootUri);

        crawler.run();

        System.out.println("Ending ImageCrawlerTestOld");
    }

    /**
     * This method is the static main() entry point to run the console
     * version of the ImageCrawler app.
     */
    // @Test
    public void testLocalImageCrawler() {
        System.out.println("Starting testLocalImageCrawler");

        // Device protects itself from multiple builds and this
        // method gets around that restriction.
        Device.setPrivateInstanceFieldToNullForUnitTestingOnly();

        // Create a new device with a local page crawler.
        Device.newBuilder()
            .platform(new JavaPlatform())
            .options(Options.newBuilder()
                     .local(true)
                     .diagnosticsEnabled(true)
                     .build())
            .crawler(new LocalPageCrawler())
            .build();

        // Run the tests.
        runTimingTests();

        System.out.println("Ending ImageCrawlerTestOld");
    }

    /**
     * This method is the static main() entry point to run the console
     * version of the ImageCrawler app.
     */
    // @Test
    public void testWebImageCrawler() {
        System.out.println("Starting testLocalImageCrawler");

        // Device protects itself from multiple builds and this
        // method gets around that restriction.
        Device.setPrivateInstanceFieldToNullForUnitTestingOnly();

        // Create a new device with a local page crawler.
        Device.newBuilder()
            .platform(new JavaPlatform())
            .options(Options.newBuilder()
                     .local(false)
                     .diagnosticsEnabled(true)
                     .build())
            .crawler(new WebPageCrawler())
            .build();

        // Run the tests.
        runTimingTests();

        System.out.println("Ending ImageCrawlerTestOld");
    }

    /**
     * Iterate through all the implementation strategies to test how
     * they perform.
     */
    private void runTimingTests() {
        // Options.instance().setDiagnosticsEnabled(true);

        // Iterate through the implementation strategies and test them.
        // Make an ImageCrawlerAsync object via the factory method.
        makeImageCrawler(Device.options().getRootUri()).forEach(crawler -> {
                String test = crawler.getClass().getSimpleName();
                System.out.println("Starting " + test);

                // Delete any the filtered images from the previous run.
                CacheUtils.clearCache();

                // Start running the test.
                crawler.run();

                // Store the execution times.
                mResultsMap.put(test, crawler.executionTimes());

                // Run the garbage collector to avoid perturbing the test.
                System.gc();

                System.out.println("Ending " + test);
            });

        // Print out all the timing results.
        printTimingResults(mResultsMap);
    }

    /**
     * Factory method that creates the designated type of ImageCrawlerAsync
     * subclass implementation.
     */
    private List<ImageCrawlerBase> makeImageCrawler(String rootUri) {
        return
            CrawlerFactory.newCrawlers(
                                       Arrays.asList(CrawlerFactory.Type.values()),
                                       Arrays.asList(FilterFactory.Type.values()),
                                       rootUri);
    }

    /**
     * Print out all the timing results for all the test runs in order
     * from fastest to slowest.
     */
    private void printTimingResults(Map<String, List<Long>> resultsMap) {
        // Determine how many runs of the tests took place.
        int numberOfRuns =
            resultsMap.entrySet().iterator().next().getValue().size();

        // Iterate through the results of each of the test runs.
        for (int i = 0; i < numberOfRuns; i++) {
            final int runNumber = i;
            System.out.println("\nPrinting "
                               + resultsMap.entrySet().size()
                               + " results for input file "
                               + (runNumber + 1)
                               + " from fastest to slowest");

            // Print out the contents of the resultsMap in sorted
            // order.
            resultsMap
                // Get the entrySet for the resultsMap.
                .entrySet()

                // Convert the entrySet into a stream.
                .stream()

                // Create a SimpleImmutableEntry containing the timing
                // results (value) followed by the test name (key).
                .map(entry
                     -> new AbstractMap.SimpleImmutableEntry<>
                     (entry.getValue().get(runNumber),
                      entry.getKey()))

                // Sort the stream by the timing results (key).
                .sorted(Comparator
                        .comparing(AbstractMap
                                   .SimpleImmutableEntry::getKey))

                // Print all the entries in the sorted stream.
                .forEach(entry
                         -> System.out.println(""
                                               + entry.getValue()
                                               + " executed in "
                                               + entry.getKey()
                                               + " msecs"));
        }
    }

    /**
     * @return this library project's resource directory.
     */
    private static File getResourcesDir() throws Exception {
        File resDir = new File(new File(".").getCanonicalFile(), RESOURCES_PATH);
        assertTrue(resDir.isDirectory());
        return resDir;
    }

    /**
     * @return this parent project's assets directory.
     */
    private static File getAssetsDir() throws Exception {
        File assetsDir = new File(new File(".").getCanonicalFile(), ASSETS_PATH);
        assertTrue(assetsDir.isDirectory());
        return assetsDir;
    }
}
